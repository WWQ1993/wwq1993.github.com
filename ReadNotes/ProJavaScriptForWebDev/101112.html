<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <meta http-equiv="content-type" content="text/html;charset=UTF-8">
   <style type="text/css">
   /*
CSS stylesheet is based on killwing's flavored markdown style:
https://gist.github.com/2937864
*/
body{
margin: 0 auto;
font: 12px/1.5em Tahoma;
letter-spacing:0.1em;
color: #444444;
line-height: 1;
width: 840px;
padding: 5px;
}
h1, h2, h3, h4 {
color: #111111;
font-weight: 400;
}
h1, h2, h3, h4, h5, p {
margin-bottom: 16px;
padding: 0;
}
h1 {
margin: 15px auto;
text-align: center;
font-size: 28px;
}
h2 {
font-size: 24px;

}
h3 {
font-size: 20px;
margin: 8px 16px ;
}
h4 {
font-size: 16px;
}
h5 {
font-size: 14px;
}
a {
color: #0099ff;
margin: 0;
padding: 0;
vertical-align: baseline;
}
a:link,a:visited{
text-decoration:none;
}
a:hover{
text-decoration:underline;
}
ul, ol {
padding: 0;
margin: 0;
}
li {
line-height: 24px;
margin-left: 40px;
}
li ul, li ol {
margin-left: -5px;
//margin-top:-15px;
          color: #000080;

}
ul, ol {
font-size: 14px;
line-height: 20px;
max-width: 840px;
}

p {
font-size: 14px;
line-height: 20px;
max-width: 840px;
margin-top: 3px;
}

pre {
padding: 0px 4px;
max-width: 800px;
white-space: pre-wrap;
font-family: Consolas, Monaco, Andale Mono, monospace;
line-height: 1.5;
font-size: 13px;
border: 1px solid #ddd;
background-color: #f7f7f7;
border-radius: 3px;
}
code {
font-family: Consolas, Monaco, Andale Mono, monospace;
line-height: 1.5;
font-size: 13px;
border: 1px solid #ddd;
background-color: #f7f7f7;
border-radius: 3px;
}
pre code {
border: 0px;
}
aside {
display: block;
float: right;
width: 800px;
}
blockquote {
border-left:.5em solid #40AA53;
padding: 0 2em;
margin-left:0;
max-width: 800px;
}
blockquote  cite {
font-size:14px;
line-height:20px;
color:#bfbfbf;
}
blockquote cite:before {
content: '\2014 \00A0';
}

blockquote p {
color: #666;
max-width: 760px;
}
hr {
height: 1px;
border: none;
border-top: 1px dashed #0066CC
}

button,
input,
select,
textarea {
font-size: 100%;
margin: 0;
vertical-align: baseline;
*vertical-align: middle;
}
button, input {
line-height: normal;
*overflow: visible;
}
button::-moz-focus-inner, input::-moz-focus-inner {
border: 0;
padding: 0;
}
button,
input[type="button"],
input[type="reset"],
input[type="submit"] {
cursor: pointer;
-webkit-appearance: button;
}
input[type=checkbox], input[type=radio] {
cursor: pointer;
}
/* override default chrome & firefox settings */
input:not([type="image"]), textarea {
-webkit-box-sizing: content-box;
-moz-box-sizing: content-box;
box-sizing: content-box;
}

input[type="search"] {
-webkit-appearance: textfield;
-webkit-box-sizing: content-box;
-moz-box-sizing: content-box;
box-sizing: content-box;
}
input[type="search"]::-webkit-search-decoration {
-webkit-appearance: none;
}
label,
input,
select,
textarea {
font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 13px;
font-weight: normal;
line-height: normal;
margin-bottom: 18px;
}
input[type=checkbox], input[type=radio] {
cursor: pointer;
margin-bottom: 0;
}
input[type=text],
input[type=password],
textarea,
select {
display: inline-block;
width: 210px;
padding: 4px;
font-size: 13px;
font-weight: normal;
line-height: 18px;
height: 18px;
color: #808080;
border: 1px solid #ccc;
-webkit-border-radius: 3px;
-moz-border-radius: 3px;
border-radius: 3px;
}
select, input[type=file] {
height: 27px;
line-height: 27px;
}
textarea {
height: auto;
}

/* grey out placeholders */
:-moz-placeholder {
color: #bfbfbf;
}
::-webkit-input-placeholder {
color: #bfbfbf;
}

input[type=text],
input[type=password],
select,
textarea {
-webkit-transition: border linear 0.2s, box-shadow linear 0.2s;
-moz-transition: border linear 0.2s, box-shadow linear 0.2s;
transition: border linear 0.2s, box-shadow linear 0.2s;
-webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
-moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}
input[type=text]:focus, input[type=password]:focus, textarea:focus {
outline: none;
border-color: rgba(82, 168, 236, 0.8);
-webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
-moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
}

/* buttons */
button {
display: inline-block;
padding: 4px 14px;
font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 13px;
line-height: 18px;
-webkit-border-radius: 4px;
-moz-border-radius: 4px;
border-radius: 4px;
-webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
-moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
background-color: #0064cd;
background-repeat: repeat-x;
background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));
background-image: -moz-linear-gradient(top, #049cdb, #0064cd);
background-image: -ms-linear-gradient(top, #049cdb, #0064cd);
background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));
background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);
background-image: -o-linear-gradient(top, #049cdb, #0064cd);
background-image: linear-gradient(top, #049cdb, #0064cd);
color: #fff;
text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
border: 1px solid #004b9a;
border-bottom-color: #003f81;
-webkit-transition: 0.1s linear all;
-moz-transition: 0.1s linear all;
transition: 0.1s linear all;
border-color: #0064cd #0064cd #003f81;
border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
}
button:hover {
color: #fff;
background-position: 0 -15px;
text-decoration: none;
}
button:active {
-webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
-moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}
button::-moz-focus-inner {
padding: 0;
border: 0;
}
/* table  */
table {
border-spacing: 0;
border: 1px solid #ccc;
}
td, th{
border: 1px solid #ccc;
padding: 5px;
}
/* code syntax highlight.
Documentation: http://www.mdcharm.com/documentation/code_syntax_highlighting.html#custom_your_own
*/
pre .literal,
pre .comment,
pre .template_comment,
pre .diff .header,
pre .javadoc {
color: #008000;
}

pre .keyword,
pre .css .rule .keyword,
pre .winutils,
pre .javascript .title,
pre .nginx .title,
pre .subst,
pre .request,
pre .status {
color: #0000FF;
font-weight: bold
}

pre .number,
pre .hexcolor,
pre .python .decorator,
pre .ruby .constant {
color: #0000FF;
}

pre .string,
pre .tag .value,
pre .phpdoc,
pre .tex .formula {
color: #D14
}

pre .title,
pre .id {
color: #900;
font-weight: bold
}

pre .javascript .title,
pre .lisp .title,
pre .clojure .title,
pre .subst {
font-weight: normal
}

pre .class .title,
pre .haskell .type,
pre .vhdl .literal,
pre .tex .command {
color: #458;
font-weight: bold
}

pre .tag,
pre .tag .title,
pre .rules .property,
pre .django .tag .keyword {
color: #000080;
font-weight: normal
}

pre .attribute,
pre .variable,
pre .lisp .body {
color: #008080
}

pre .regexp {
color: #009926
}

pre .class {
color: #458;
font-weight: bold
}

pre .symbol,
pre .ruby .symbol .string,
pre .lisp .keyword,
pre .tex .special,
pre .prompt {
color: #990073
}

pre .built_in,
pre .lisp .title,
pre .clojure .built_in {
color: #0086b3
}

pre .preprocessor,
pre .pi,
pre .doctype,
pre .shebang,
pre .cdata {
color: #999;
font-weight: bold
}

pre .deletion {
background: #fdd
}

pre .addition {
background: #dfd
}

pre .diff .change {
background: #0086b3
}

pre .chunk {
color: #aaa
}

pre .markdown .header {
color: #800;
font-weight: bold;
}

pre .markdown .blockquote {
color: #888;
}

pre .markdown .link_label {
color: #88F;
}

pre .markdown .strong {
font-weight: bold;
}

pre .markdown .emphasis {
font-style: italic;
}

   </style>
   
   
</head>
<body>
    <h1 id="c10">第十章 DOM <sup><a href="0.html#catalogue">回目录</a></sup></h1>

<h2>10.1 节点层次</h2>

<ul>
<li>多层节点结构：DOM 可以将任何HTML 或XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点
为根节点的树形结构。</li>
<li>文档节点是每个文档的根节点。</li>
<li>文档元素：文档节点只有一个子节点，即 文档元素。是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。在HTML 页面中，文档元素始终都是&lt;html&gt;元素。</li>
<li>每一段标记都可以通过树中的一个节点来表示： 元素通过元素节点表示，特性（attribute）
通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。</li>
</ul>

<h3>10.1.1 Node类型</h3>

<ul>
<li>Node 接口：实现所有节点类型。JavaScript 中的所有节点类型都继承自Node 类型。</li>
<li><p>每个节点都有一个nodeType 属性，用于表明节点的类型。节点类型由在Node 类型中定义的12 个数值常量来表示。通过和这些常量比较，可以很容易地确定节点的类型，（ 为了确保跨浏览器兼容，最好还是将nodeType 属性与数字值进行比较），如下所示：</p>

<pre><code class="javascript"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>){ <span class="comment">//适用��</span>�所有浏览器
alert("Node is an element.");
}
</code></pre></li>
</ul>

<ol>
<li>nodeName 和nodeValue 属性。对于元素节点，nodeName 中保存的始终都是元素的标签名，而nodeValue 的值则始终为null。</li>
<li>节点关系

<ul>
<li>每个节点都有一个childNodes 属性，其中保存着一个NodeList 对象。

<ul>
<li>NodeList 是一种类数组对象(类似arguments)，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList 对象的
独特之处在于，它实际上是基于DOM 结构<strong>动态执行查询</strong>的结果，因此DOM结构的变化能够自动反映在NodeList 对象中。访问保存在NodeList 中的节点——可以通过方括号，也可以使用item()
方法。</li>
<li>length 属性表示的是访问NodeList 的那一刻，其中包含的节点数量</li>
</ul></li>
<li>每个节点都有一个parentNode 属性，该属性指向文档树中的父节点。同胞节点具有相同的父节点。</li>
<li>previousSibling和nextSibling 属性，可以访问同一NodeList 列表中的其他节点。列表中第一个节点的previousSibling 属性
值为null，而列表中最后一个节点的nextSibling 属性的值同样也为null。</li>
<li>父节点的firstChild 和lastChild
属性分别指向其childNodes 列表中的第一个和最后一个节点。其中，someNode.firstChild 的值
始终等于someNode.childNodes[0] ， 而someNode.lastChild 的值始终等于someNode.
childNodes [someNode.childNodes.length-1]。</li>
<li>hasChildNodes()在节点包含一或多个子节点的情况下返回true；应该说，这是比查询childNodes
列表的length 属性更简单的方法。</li>
<li>ownerDocument（每个节点都有此属性），该属性指向表示整个文档的文档节点，通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。</li>
<li>关系指针都是只读的。</li>
</ul></li>
<li> 操作节点：以下四个方法操作的都是某个节点的子节点，也就是说，使用父节点调用以下方法。

<ul>
<li>appendChild()，用于向childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增
节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()
返回新增的节点。格式：<code>parentNode.appendChild（newNode）</code></li>
<li>insertBefore()方法：把节点放在childNodes 列表中某个特定的位置上，而不是放在末尾，那么这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作。</li>
<li>replaceChild()方法，接受两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。</li>
<li>只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值</li>
<li>被替换或删除的节点仍然还在文档中，但它在文档中已经没有了自己的位置，成为了一个<strong>“孤儿”</strong>，除非通过appendChild()、insertBefore()或replaceChild()将它将他添加到文档中。</li>
</ul></li>
<li> 其他方法

<ul>
<li>cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为true的情况下执行深复制，也就是复制节点及其整个子节点树；在参数为false 的情况下执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”（见上文）。</li>
<li>normalize()，作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</li>
</ul></li>
</ol>

<h3>10.1.2 Document类型</h3>

<ul>
<li>JavaScript 通过Document 类型表示文档。document 对象是HTMLDocument（继承
自Document 类型）的一个实例，表示整个HTML 页面。</li>
<li>document 对象是window 对象的一个属性，因此可以将其作为全局对象来访问。</li>
</ul>

<ol>
<li>文档的子节点

<ul>
<li>Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment。</li>
<li>documentElement
属性，该属性始终指向HTML 页面中的&lt;html&gt;元素。（也可以通过childNodes列表方式来访问文档元素，documentElement、firstChild 和childNodes[0]的值相同，都指向&lt;html&gt;
元素。）</li>
<li>document 对象还有一个body 属性，直接指向&lt;body&gt;元素。</li>
<li>Document 另一个可能的子节点是DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过<code>document.doctype</code>来访问它的信息。(由于浏览器对document.doctype 的支持不一致，因此这个属性的用处很有限。)</li>
</ul></li>
<li><p>文档信息</p>

<ul>
<li>title属性，包含着&lt;title&gt;元素中的文本——显示在浏览器窗口的标题栏或标签页上。</li>
<li>URL、domain 和referrer。

<ul>
<li>URL 属性中包含页面完整的URL（即地址栏中显示的URL）</li>
<li>domain 属性中只包含页面的域名。通过将domain值设为松散型域名，从而实现不同子域页面通信。</li>
<li>referrer属性中则保存着链接到当前页面的那个页面的URL。在没有来源页面的情况下，referrer 属性中可能会包含空字符串。</li>
<li>所有这些信息都存在于请求的HTTP 头部，只不过是通过这些属性让我们能够在JavaScrip 中访问它们而已。</li>
</ul></li>
</ul></li>
<li><p>查找元素</p>

<ul>
<li>getElementById()，接收一个参数：要取得的元素的ID。找到则返回该元素，不存在带有相应ID 的元素则返回null。注意，这里的ID 必须与页面中元素的id特性（attribute）严格匹配，包括大小写。

<ul>
<li>如果页面中多个元素的ID 值相同，getElementById()只返回文档中第一次出现的元素。</li>
</ul></li>
<li><p>getElementsByTagName()。接受一个参数，即要取得元素的标签名，返回一个HTMLCollection <strong>对象</strong></p>

<ul>
<li><p>作为一个“动态”集合，HTMLCollection 对象与NodeList 非常类似。可以使用方括号语法或item()方法来访问对象中的项，元素的数量则可以通过length取得。还有一个namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。</p>

<ul>
<li>对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用item()，而对字符串索引就会调用namedItem()。要想取得文档中的所有元素，可以向getElementsByTagName()中传入&quot;*&quot;，返回的HTMLCollection 中，就包含了整个页面中的所有元素——按照它们出现的
先后顺序。在JavaScript 及CSS中，星号（*）通常表示“全部”</li>
</ul>

<pre><code class="javascript">&lt;img src=<span class="string">"myimage.gif"</span> name=<span class="string">"myImage"</span>&gt;
<span class="keyword">var</span> myImage =document.getElementsByTagName(<span class="string">"img"</span>).namedItem(<span class="string">"myImage"</span>);
<span class="keyword">var</span> myImage =document.getElementsByTagName(<span class="string">"img"</span>)[<span class="string">"myImage"</span>];
</code></pre></li>
</ul></li>
<li><p>getElementsByName()。返回带有给定name 特性的所有元素（namedItem()方法则只会取得第一项）。最常使用getElementsByName()方法的情况是取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的name 特性。</p></li>
</ul></li>
<li><p>特殊集合：这些集合都是HTMLCollection 对象，会随着当前文档内容的更新而更新</p>

<ol>
<li>document.anchors，包含文档中所有带name 特性的&lt;a&gt;元素；</li>
<li>document.forms，包含文档中所有的&lt;form&gt;元素</li>
<li>document.images，包含文档中所有的&lt;img&gt;元素</li>
<li>document.links，包含文档中所有带href 特性的&lt;a&gt;元素。</li>
</ol></li>
<li><p>DOM 一致性检测</p>

<ul>
<li>hasFeature()。接受两个参数：要检测的DOM 功能的名称及版本号。</li>
</ul></li>
<li><p>文档写入</p>

<ul>
<li>write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。

<ul>
<li>不能直接包含字符串&quot;&lt;/script&gt;&quot;，这会导致该字符串被解释为脚本块的结束，后面的代码将无法执行。要转义为&quot;&lt;\/script&gt;&quot;。</li>
<li>如果在文档加载结束后再调用document.write()，那么输出的内容将会重写整个页面</li>
</ul></li>
<li>open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法</li>
</ul></li>
</ol>

<h3>10.1.3 Element类型</h3>

<ul>
<li>nodeName属性和tagName属性返回元素的标签名（在HTML 中，标签名始终都以全部大写表示）</li>
</ul>

<ol>
<li><p>HTML 元素</p>

<ul>
<li>所有 HTML 元素都由HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示</li>
<li><p>每个HTML元素中都存在的下列标准<strong>特性</strong>。</p>

<ol>
<li>id，元素在文档中的唯一标识符。</li>
<li>title，有关元素的附加说明信息，一般通过工具提示条显示出来。</li>
<li>lang，元素内容的语言代码，很少使用。</li>
<li>dir，语言的方向，也很少使用。</li>
<li>className，与元素的class特性对应，即为元素指定的CSS类。修改className 时，如果新类关联了与此前不同的CSS 样式，那么就会立即应用新的样式。</li>
</ol>

<pre><code class="javascript"><span class="keyword">var</span> div = document.getElementById(<span class="string">"myDiv"</span>);
alert(div.id); <span class="comment">//"myDiv""</span>
</code></pre></li>
<li><p>所有HTML 元素以及与之关联的类型。<sup>P263</sup></p></li>
</ul></li>
<li><p>取得特性</p>

<ul>
<li><p>getAttribute()：接受特性名，返回该特性值。</p>

<pre><code class="javascript"><span class="keyword">var</span> div = document.getElementById(<span class="string">"myDiv"</span>);
alert(div.getAttribute(<span class="string">"id"</span>)); <span class="comment">//"myDiv"</span>
</code></pre></li>
<li><p>通过 getAttribute()方法也可以取得自定义特性值。（自定义特性应该加上data-前缀以便验证）</p></li>
<li><p>只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中，所以不能用div.data-*形式访问到自定义特性，只能用上述方法。</p></li>
<li><p>在通过JavaScript 以编程方式操作DOM 时，开发人员经常不使用getAttribute()，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用getAttribute()方法。</p></li>
</ul></li>
<li><p>设置特性</p>

<ul>
<li>setAttribute()，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性并设置相应的值。</li>
<li>通过 setAttribute()方法既可以操作HTML 特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式</li>
<li>removeAttribute()，这个方法用于彻底删除元素的特性。传入属性名。</li>
</ul></li>
<li><p>attributes 属性</p>

<ul>
<li>Element 类型是使用attributes 属性的唯一一个DOM 节点类型。attributes 属性中包含一个NamedNodeMap，也是一个“动态”的集合。元素的每一个特性都由一个Attr 节点表示，每个节点都保存在NamedNodeMap 对象中。</li>
<li>NamedNodeMap 对象拥有下列方法。

<ol>
<li>getNamedItem(name)：返回nodeName 属性等于name 的节点；</li>
<li>removeNamedItem(name)：从列表中移除nodeName 属性等于name 的节点；</li>
<li>setNamedItem(node)：向列表中添加节点，以节点的nodeName 属性为索引；</li>
<li>item(pos)：返回位于数字pos 位置处的节点</li>
</ol></li>
<li>attributes 属性中包含一系列节点，每个节点的nodeName 就是特性的名称，而节点的nodeValue就是特性的值。</li>
<li>由于attributes 的方法不够方便，因此开发人员更多的会使用getAttribute()、removeAttribute()和setAttribute()方法。</li>
</ul></li>
<li><p>创建元素</p>

<ul>
<li>document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。会返回一个DOM 元素的引用。同时也为新元素设置了ownerDocuemnt 属性。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用appendChild()、insertBefore()或replaceChild()方法。</li>
<li>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</li>
</ul></li>
<li><p>元素的子节点</p>

<ul>
<li><p>通过某个特定的标签名取得子节点或后代节点</p>

<pre><code class="javascript"><span class="keyword">var</span> ul = document.getElementById(<span class="string">"myList"</span>);
<span class="keyword">var</span> items = ul.getElementsByTagName(<span class="string">"li"</span>);
</code></pre>

<p>要注意的是，这里&lt;ul&gt;的后代中只包含直接子元素。不过，如果它包含更多层次的后代元素，那
么各个层次中包含的&lt;li&gt;元素也都会返回。</p></li>
</ul></li>
</ol>

<h3>10.1.4 Text类型</h3>

<ul>
<li>Text 节点具有以下特征：

<ol>
<li>nodeType 的值为3；</li>
<li>nodeName 的值为&quot;#text&quot;；</li>
<li>nodeValue(或data 属性) 的值为节点所包含的文本；</li>
<li>parentNode 是一个Element；</li>
<li>不支持（没有）子节点。</li>
</ol></li>
<li>length 属性，保存着节点中字符的数目。</li>
<li>方法：

<ul>
<li>appendData(text)：将text 添加到节点的末尾。</li>
<li>deleteData(offset, count)：从offset 指定的位置开始删除count 个字符。</li>
<li>insertData(offset, text)：在offset 指定的位置插入text。</li>
<li>replaceData(offset, count, text)：用text 替换从offset 指定的位置开始到offset+count 为止处的文本。</li>
<li>splitText(offset)：从offset 指定的位置将当前文本节点分成两个文本节点。</li>
<li>substringData(offset, count)：提取从offset 指定的位置开始到offset+count 为止处的字符串。</li>
</ul></li>
<li>在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。开始与结束标签之间只要存在内容，就会创建一个文本节点。</li>
</ul>

<pre><code class="html"><span class="comment">&lt;!-- 没有内容，也就没有文本节点 --&gt;
&lt;div&gt;&lt;/div&gt;
&lt;!-- 有空格，因而有一个文本节点 --&gt;
&lt;div&gt; &lt;/div&gt;
&lt;!-- 有内容，因而有一个文本节点 --&gt;
&lt;div&gt;Hello World!&lt;/div&gt;
</code></pre>

<ul>
<li>一般情况下，每个元素只有一个文本子节点。不过，在某些情况下也可能包含多个文本子节点。浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。</li>
</ul>

<ol>
<li><p>创建文本节点</p>

<ul>
<li>document.createTextNode()创建新文本节点，这个方法接受一个参数——要插入节点中的文本。返回该文本元素。</li>
<li>最后一步，就是将这个元素添加到了文档的<body>
元素中，这样就可以在浏览器中看到新创建的元素和文本节点了。</li>
</ul></li>
<li><p>规范化文本节点</p>

<ul>
<li>normalize()。如果
在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个
节点，结果节点的nodeValue 等于将合并前每个文本节点的nodeValue 值拼接起来的值。</li>
</ul></li>
<li><p>分割文本节点</p></li>
</ol>

</body>
</html>